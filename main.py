import numpy as np
import pandas as pd
import jieba
from gensim.models.word2vec import Word2Vec
from gensim.models import word2vec
import numpy as np
from sklearn.neighbors import KNeighborsClassifier
from sklearn.preprocessing import OneHotEncoder
from sklearn.preprocessing import LabelEncoder
from sklearn.metrics import accuracy_score
from sklearn.model_selection import train_test_split
from sklearn import ensemble, preprocessing, metrics
from collections import Counter
import time
from sklearn.svm import SVC
from sklearn import svm
from sklearn.metrics import precision_score
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.feature_extraction.text import TfidfTransformer
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics import confusion_matrix

sys=[]
tfidf=[]
countnum=[]

with open("CDMC2019Task2Train.label") as f:
  a=[]
  for lines in f:
      tmp=lines.split()
      for j in tmp:
          c=j.split(',')
          #print(c[1])
          a.append(c[1])
  a=np.array(a)  
  
with open("Test.label") as f:
  b=[]
  for lines in f:
      tmp=lines.split()
      for j in tmp:
          c=j.split(',')
          #print(c[1])
          b.append(c[1])
  b=np.array(b) 

def read_label(label):
    df = pd.read_csv("CDMC2019Task2Train.csv")
    df=df.iloc[:,1:]
    print(df.shape)

    #label=[]
    for i in range(df.shape[0]):
        label.append(df.iloc[i,:].to_numpy().flatten())
    label=np.array(label)
    
    return label

def sys_call():
    with open("malwaresys.txt") as f:
        for lines in f:
            tmp=lines.split()
            for j in tmp:
                sys.append(j)

def get_label(array):
    tmp=[]
    for i in range(len(array)):
        for j in range(len(sys)):
            if array[i] == sys[j]:
                tmp.append(j)
                break
    return tmp

def rf_train(k,train):
    print("TRAINNING DATA COLLECTING")
    for i in range(1,k):
        r=[]
        i = "%04d" % i
        print("i",i)
        with open("./TRAIN/"+str(i)+".seq") as f:
            c=0
            for lines in f:
                tmp=lines.split()
                for j in tmp:
                    r.append(j)
                    c=c+1
        r=sorted(set(r), key=r.index)
        r=np.array(r).astype(str)
        #print(r)
        data_le=get_label(r)
        print(len(data_le))
        result=[]
        for i in range(0,len(data_le)):
            result.append(data_le[i])
        #print(result)       
        ff=[0]*122
        #tf=[0]*303
        for i in result:
            ff[i]+=1
        #    tf[i]=tf[i]+1
           
        result=np.array(result)
        ff=np.array(ff)
        #tf=np.array(tf)
        print(ff)
        #print(result)
        train.append(ff)
        #tfidf.append(tf)
    return train


def rf_test(k,test):
    print("TESTING DATA COLLECTING")
    
    for i in range(1,k):
        r=[]
        i = "%04d" % i
        print("i",i)
        with open("./TEST/"+str(i)+".seq") as f:
            c=0
            for lines in f:
                tmp=lines.split()
                for j in tmp:
                    r.append(j)
                    c=c+1
        r=sorted(set(r), key=r.index)
        r=np.array(r).astype(str)
        #print(r)
        data_le=get_label(r)
        print(len(data_le))
        result=[]
        for i in range(0,len(data_le)):
            result.append(data_le[i])
        #print(result)       
        ff=[0]*122
        #tf=[0]*303
        for i in result:
            ff[i]+=1
        #    tf[i]=tf[i]+1
           
        result=np.array(result)
        ff=np.array(ff)
        #tf=np.array(tf)
        print(ff)
        #print(result)
        test.append(ff)
        #tfidf.append(tf)
   
    return test

if __name__ == "__main__":
    #label data
    label=[]
    label=read_label(label)
    label=np.array(label)
    print(label)
    a=a.reshape(a.shape[0],1)
    print(a.shape)
    sys_call()
    #trainnig data
    train=[]
    train=rf_train(4168,train)#4167
    train=np.array(train)
       
    test=[]
    test=rf_test(4276,test)
    test=np.array(test)
    
    #print(test)
  
    X_train,X_test,Y_train,Y_test= train_test_split(train,a,test_size=0.3)
    
    print("START TRAINNING")
    #KNN TRAINNING
    knn = KNeighborsClassifier()
    knn.fit(X_train, Y_train)
    y_predict = knn.predict(X_test)

    print(y_predict)   
    print("KNN accuracy:",accuracy_score(Y_test,y_predict))
    print("KNN precision:",precision_score(Y_test,y_predict, average=None))
   
    
    # 建立 random forest 模型
    forest = ensemble.RandomForestClassifier(n_estimators = 40)
    forest_fit = forest.fit(X_train, Y_train)
    # 預測
    test_y_predicted = forest.predict(X_test)
    
    print(test_y_predicted)    
    print("RF(40) accuracy:",accuracy_score(Y_test,test_y_predicted))
    print("RF(40) precision:",precision_score(Y_test,test_y_predicted, average=None))
    
    for i in range(len(Y_test)):
       if Y_test[i]!=test_y_predicted[i]:
           print(i,Y_test[i],test_y_predicted[i])
    
    print("----------------------------------------------------------------------------------")
    print("TESTING")

    #KNN TRAINNING
    knn = KNeighborsClassifier()
    knn.fit(train, a)
    y_predict = knn.predict(test)

    print(y_predict)   
    print("KNN accuracy:",accuracy_score(b,y_predict))
    print("KNN precision:",precision_score(b,y_predict, average=None))
    C=confusion_matrix(b,y_predict)
    print(C)

   
    
    # 建立 random forest 模型
    forest = ensemble.RandomForestClassifier(n_estimators = 40)
    forest_fit = forest.fit(train, a)
    # 預測
    test_y_predicted = forest.predict(test)
    
    print(test_y_predicted)    
    print("RF(40) accuracy:",accuracy_score(b,test_y_predicted))
    print("RF(40) precision:",precision_score(b,test_y_predicted, average=None))
    C=confusion_matrix(b,test_y_predicted)
    print(C)
    
    
