import numpy as np
import pandas as pd
import jieba
from gensim.models.word2vec import Word2Vec
from gensim.models import word2vec
import numpy as np
from sklearn.neighbors import KNeighborsClassifier
from sklearn.preprocessing import OneHotEncoder
from sklearn.preprocessing import LabelEncoder
from sklearn.metrics import accuracy_score
from sklearn.model_selection import train_test_split
from sklearn import ensemble, preprocessing, metrics

zero=[0, 0, 0, 0, 0, 0, 0, 0]

def read_label(label):
    df = pd.read_csv("CDMC2019Task2Train.csv", encoding="ANSI")
    df=df.iloc[:,1:]
    print(df.shape)

    #label=[]
    for i in range(df.shape[0]):
        label.append(df.iloc[i,:].to_numpy().flatten())
    label=np.array(label)
    
    return label

def get_bin(x, n=0):
    
    return format(x, 'b').zfill(n)

def rf_train(k,train):
    print("TRAINNING DATA COLLECTING")
    for i in range(1,k):
        r=[]
        i = "%04d" % i
        #print("i",i)
        with open("./TRAIN/"+str(i)+".seq") as f:
            #next(f)
            c=0
            for lines in f:
        #print(c,lines.split())
                tmp=lines.split()
                for j in tmp:
                    r.append(j)
                    c=c+1
        r=np.array(r)
        labelencoder = LabelEncoder()
        data_le=pd.DataFrame(r)
        print(i,len(data_le))
        data_le = labelencoder.fit_transform(data_le)
        result=[]
        for i in range(0,len(data_le)):
            #print(get_bin(data_le[i],8))
            t=get_bin(data_le[i],8)
            tmp=[]
            for j in range(8):
                tmp.append(int(t[j]))
            result.append(tmp)
        #print(len(result))
        if len(result)<=190000:
            for i in range(190000-len(result)):
                
                result.append(zero)
        result=np.array(result)
        train.append(result)
        
    return train

def rf_test(k,test):
    print("TESTING DATA COLLECTING")
    for i in range(1,k):
        r=[]
        i = "%04d" % i
        #print("i",i)
        with open("./TEST/"+str(i)+".seq") as f:
            #next(f)
            c=0
            for lines in f:
        #print(c,lines.split())
                tmp=lines.split()
                for j in tmp:
                    r.append(j)
                    c=c+1
        r=set(np.array(r))
        labelencoder = LabelEncoder()
        data_le=pd.DataFrame(r)
        print(i,len(data_le))
        data_le = labelencoder.fit_transform(data_le)
        result=[]
        for i in range(0,len(data_le)):
            #print(get_bin(data_le[i],8))
            t=get_bin(data_le[i],8)
            tmp=[]
            for j in range(8):
                tmp.append(int(t[j]))
            result.append(tmp)
        if len(result)<=100:
            for i in range(100-len(result)):
                result.append(zero)
        result=np.array(result)
        test.append(result)
        
    return test     
        

if __name__ == "__main__":
    #label data
    label=[]
    label=read_label(label)
    label=np.array(label)
    #trainnig data
    train=[]
    train=rf_train(4167,train)
    train=np.array(train)
    #testing data
    #test=[]
    #test=rf_test(4274,test)
    #test=np.array(test)
    
    #reshape
    nsamples, nx, ny = train.shape
    train = train.reshape((nsamples,nx*ny))
    #nsamples, nx, ny = test.shape
    #test = test.reshape((nsamples,nx*ny))
 
    #print(train.shape)
    #print(label.shape)
    #print(test)
    
    X_train,X_test,Y_train,Y_test= train_test_split(train,label,test_size=0.3)
    
  
    #KNN TRAINNING
  #  knn = KNeighborsClassifier()
  #  knn.fit(X_train, Y_train)
  #  y_predict = knn.predict(X_test)

  #  print(y_predict)   
  #  print(accuracy_score(Y_test,y_predict))
    
    # 建立 random forest 模型
    forest = ensemble.RandomForestClassifier(n_estimators = 100)
    forest_fit = forest.fit(X_train, Y_train)
    # 預測
    test_y_predicted = forest.predict(X_test)
    
    print(test_y_predicted)    
    print(accuracy_score(Y_test,test_y_predicted))


